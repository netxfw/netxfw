package app

import (
	"context"
	"fmt"
	"log"
	"net/http"
	_ "net/http/pprof"
	"strconv"

	"github.com/livp123/netxfw/internal/api"
	"github.com/livp123/netxfw/internal/config"
	"github.com/livp123/netxfw/internal/core"
	"github.com/livp123/netxfw/internal/core/engine"
	"github.com/livp123/netxfw/internal/daemon"
	"github.com/livp123/netxfw/internal/plugins"
	"github.com/livp123/netxfw/internal/plugins/types"
	"github.com/livp123/netxfw/internal/runtime"
	"github.com/livp123/netxfw/internal/utils/logger"
	"github.com/livp123/netxfw/internal/xdp"
	"github.com/livp123/netxfw/pkg/sdk"
)

/**
 * InstallXDP initializes the XDP manager and mounts the program to interfaces, then exits.
 * InstallXDP ÂàùÂßãÂåñ XDP ÁÆ°ÁêÜÂô®Âπ∂Â∞ÜÁ®ãÂ∫èÊåÇËΩΩÂà∞Êé•Âè£ÔºåÁÑ∂ÂêéÈÄÄÂá∫„ÄÇ
 */
func InstallXDP(ctx context.Context, cliInterfaces []string) error {
	log := logger.Get(ctx)
	// Load global configuration first to get interface settings / È¶ñÂÖàÂä†ËΩΩÂÖ®Â±ÄÈÖçÁΩÆ‰ª•Ëé∑ÂèñÊé•Âè£ËÆæÁΩÆ
	cfgManager := config.GetConfigManager()
	err := cfgManager.LoadConfig()
	if err != nil {
		return fmt.Errorf("failed to load global config: %v", err)
	}

	globalCfg := cfgManager.GetConfig()
	if globalCfg == nil {
		return fmt.Errorf("config is nil after loading")
	}

	var interfaces []string
	if len(cliInterfaces) > 0 {
		interfaces = cliInterfaces
		log.Infof("‚ÑπÔ∏è  Using CLI provided interfaces: %v", interfaces)
	} else if len(globalCfg.Base.Interfaces) > 0 {
		interfaces = globalCfg.Base.Interfaces
		log.Infof("‚ÑπÔ∏è  Using configured interfaces: %v", interfaces)
	} else {
		// Auto-detect if no interfaces configured / Â¶ÇÊûúÊú™ÈÖçÁΩÆÊé•Âè£ÔºåÂàôËá™Âä®Ê£ÄÊµã
		interfaces, err = xdp.GetPhysicalInterfaces()
		if err != nil {
			return fmt.Errorf("failed to get interfaces: %v", err)
		}
		if len(interfaces) == 0 {
			return fmt.Errorf("no physical interfaces found")
		}
		log.Infof("‚ÑπÔ∏è  Auto-detected interfaces: %v", interfaces)
	}

	manager, err := xdp.NewManager(globalCfg.Capacity, log)
	if err != nil {
		return fmt.Errorf("failed to create XDP manager: %v", err)
	}
	defer manager.Close()

	if err := manager.Attach(interfaces); err != nil {
		return fmt.Errorf("failed to attach XDP program to interfaces: %v", err)
	}

	log.Infof("‚úÖ XDP program successfully mounted on %v", interfaces)
	return nil
}

/**
 * RemoveXDP detaches the XDP program from all interfaces and unpins everything.
 * RemoveXDP ‰ªéÊâÄÊúâÊé•Âè£ÂàÜÁ¶ª XDP Á®ãÂ∫èÂπ∂ÂèñÊ∂àÊâÄÊúâÂõ∫ÂÆö„ÄÇ
 */
func RemoveXDP(ctx context.Context, cliInterfaces []string) error {
	log := logger.Get(ctx)
	// Load global configuration to get max entries (needed for NewManager)
	// Âä†ËΩΩÂÖ®Â±ÄÈÖçÁΩÆ‰ª•Ëé∑ÂèñÊúÄÂ§ßÊù°ÁõÆÊï∞ÔºàNewManager ÈúÄË¶ÅÔºâ
	cfgManager := config.GetConfigManager()
	err := cfgManager.LoadConfig()
	if err != nil {
		log.Warnf("‚ö†Ô∏è  Failed to load global config, using default map capacity: %v", err)
		globalCfg := &types.GlobalConfig{}
	} else {
		globalCfg := cfgManager.GetConfig()
		if globalCfg == nil {
			globalCfg = &types.GlobalConfig{} // fallback
		}
	}

	var interfaces []string
	fullUnload := false

	if len(cliInterfaces) > 0 {
		interfaces = cliInterfaces
		log.Infof("‚ÑπÔ∏è  Detaching from specific interfaces: %v", interfaces)
	} else {
		fullUnload = true
		// Collect all potential interfaces to detach from
		// Êî∂ÈõÜÊâÄÊúâÂèØËÉΩÁöÑÂàÜÁ¶ªÊé•Âè£
		uniqueInterfaces := make(map[string]bool)

		// 1. Get physical interfaces / 1. Ëé∑ÂèñÁâ©ÁêÜÊé•Âè£
		if phyInterfaces, err := xdp.GetPhysicalInterfaces(); err == nil {
			for _, iface := range phyInterfaces {
				uniqueInterfaces[iface] = true
			}
		}

		// 2. Get interfaces from config / 2. ‰ªéÈÖçÁΩÆËé∑ÂèñÊé•Âè£
		for _, iface := range globalCfg.Base.Interfaces {
			uniqueInterfaces[iface] = true
		}

		// 3. Get currently attached interfaces from pins / 3. ‰ªéÂõ∫ÂÆöË∑ØÂæÑËé∑ÂèñÂΩìÂâçÂ∑≤ÈôÑÂä†ÁöÑÊé•Âè£
		if attachedIfaces, err := xdp.GetAttachedInterfaces(config.GetPinPath()); err == nil {
			for _, iface := range attachedIfaces {
				uniqueInterfaces[iface] = true
			}
		}

		for iface := range uniqueInterfaces {
			interfaces = append(interfaces, iface)
		}
		log.Infof("‚ÑπÔ∏è  Detaching from all detected interfaces: %v", interfaces)
	}

	manager, err := xdp.NewManager(globalCfg.Capacity, log)
	if err != nil {
		return fmt.Errorf("failed to create XDP manager: %v", err)
	}
	defer manager.Close()

	if err := manager.Detach(interfaces); err != nil {
		log.Warnf("‚ö†Ô∏è  Some interfaces could not be detached: %v", err)
	}

	if fullUnload {
		if err := manager.Unpin(config.GetPinPath()); err != nil {
			log.Warnf("‚ö†Ô∏è  Could not unpin all maps: %v", err)
		}
		log.Info("‚úÖ XDP driver removed and maps unpinned.")
	} else {
		log.Infof("‚úÖ XDP driver detached from %v", interfaces)
	}
	return nil
}

// ReloadXDP performs a hot-reload of the XDP program.
// It loads new objects, migrates state from old pinned maps, and swaps the program.
// ReloadXDP ÊâßË°å XDP Á®ãÂ∫èÁöÑÂπ≥ÊªëÈáçËΩΩÔºöÂä†ËΩΩÊñ∞ÂØπË±°Ôºå‰ªéÊóßÁöÑÂõ∫ÂÆö Map ËøÅÁßªÁä∂ÊÄÅÔºåÂπ∂ÂàáÊç¢Á®ãÂ∫è„ÄÇ
func ReloadXDP(ctx context.Context, cliInterfaces []string) error {
	log := logger.Get(ctx)
	log.Info("üîÑ Starting hot-reload of XDP program...")

	// 1. Load global configuration / Âä†ËΩΩÂÖ®Â±ÄÈÖçÁΩÆ
	cfgManager := config.GetConfigManager()
	err := cfgManager.LoadConfig()
	if err != nil {
		return fmt.Errorf("failed to load global config: %v", err)
	}

	globalCfg := cfgManager.GetConfig()
	if globalCfg == nil {
		return fmt.Errorf("config is nil after loading")
	}

	var interfaces []string
	if len(cliInterfaces) > 0 {
		interfaces = cliInterfaces
		log.Infof("‚ÑπÔ∏è  Using CLI provided interfaces: %v", interfaces)
	} else if len(globalCfg.Base.Interfaces) > 0 {
		interfaces = globalCfg.Base.Interfaces
		log.Infof("‚ÑπÔ∏è  Using configured interfaces: %v", interfaces)
	} else {
		interfaces, err = xdp.GetPhysicalInterfaces()
		if err != nil {
			return fmt.Errorf("failed to get interfaces: %v", err)
		}
		log.Infof("‚ÑπÔ∏è  Auto-detected interfaces: %v", interfaces)
	}

	// 2. Try to load old manager from pins to check capacity