package agent

import (
	"context"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/livp123/netxfw/cmd/netxfw/commands/common"
	"github.com/livp123/netxfw/internal/app"
	"github.com/livp123/netxfw/internal/core"
	"github.com/livp123/netxfw/internal/daemon"
	"github.com/livp123/netxfw/pkg/sdk"
	"github.com/spf13/cobra"
)

var SystemCmd = &cobra.Command{
	Use:   "system",
	Short: "System management commands",
	// Short: ç³»ç»Ÿç®¡ç†å‘½ä»¤
	Long: `System management commands for netxfw`,
	// Long: netxfw çš„ç³»ç»Ÿç®¡ç†å‘½ä»¤
}

var systemInitCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize configuration file",
	// Short: åˆå§‹åŒ–é…ç½®æ–‡ä»¶
	Long: `Initialize default configuration file in /root/netxfw/`,
	// Long: åœ¨ /root/netxfw/ ä¸­åˆå§‹åŒ–é»˜è®¤é…ç½®æ–‡ä»¶
	Run: func(cmd *cobra.Command, args []string) {
		// Initialize configuration
		// åˆå§‹åŒ–é…ç½®
		core.InitConfiguration(cmd.Context())
	},
}

var systemStatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show runtime status and statistics",
	// Short: æ˜¾ç¤ºè¿è¡Œæ—¶çŠ¶æ€å’Œç»Ÿè®¡ä¿¡æ¯
	Long: `Show current runtime status and statistics`,
	// Long: æ˜¾ç¤ºå½“å‰çš„è¿è¡Œæ—¶çŠ¶æ€å’Œç»Ÿè®¡ä¿¡æ¯
	Run: func(cmd *cobra.Command, args []string) {
		s, err := common.GetSDK()
		if err != nil {
			cmd.PrintErrln(err)
			os.Exit(1)
		}
		// Show system status
		// æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€
		if err := showStatus(cmd.Context(), s); err != nil {
			cmd.PrintErrln(err)
		}
	},
}

var systemTestCmd = &cobra.Command{
	Use:   "test",
	Short: "Test configuration validity",
	// Short: æµ‹è¯•é…ç½®æœ‰æ•ˆæ€§
	Long: `Test configuration validity`,
	// Long: æµ‹è¯•é…ç½®æœ‰æ•ˆæ€§
	Run: func(cmd *cobra.Command, args []string) {
		// Test configuration
		// æµ‹è¯•é…ç½®
		daemon.TestConfiguration(cmd.Context())
	},
}

var systemDaemonCmd = &cobra.Command{
	Use:   "daemon",
	Short: "Start background process",
	// Short: å¯åŠ¨åå°è¿›ç¨‹
	Long: `Start background process`,
	// Long: å¯åŠ¨åå°è¿›ç¨‹
	Run: func(cmd *cobra.Command, args []string) {
		// Run as daemon
		// ä»¥å®ˆæŠ¤è¿›ç¨‹æ–¹å¼è¿è¡Œ
		app.RunDaemon(cmd.Context())
	},
}

var interfaces []string

var systemLoadCmd = &cobra.Command{
	Use:   "load",
	Short: "Load XDP driver",
	// Short: åŠ è½½ XDP é©±åŠ¨
	Long: `Load XDP driver`,
	// Long: åŠ è½½ XDP é©±åŠ¨
	Run: func(cmd *cobra.Command, args []string) {
		common.EnsureStandaloneMode()

		if err := app.InstallXDP(cmd.Context(), interfaces); err != nil {
			cmd.PrintErrln(err)
			os.Exit(1)
		}
	},
}

var systemReloadCmd = &cobra.Command{
	Use:   "reload",
	Short: "Hot-reload XDP program with new configuration",
	// Short: ä½¿ç”¨æ–°é…ç½®çƒ­é‡è½½ XDP ç¨‹åº
	Long: `Hot-reload XDP program: applies new configuration without dropping connections.
Supports capacity changes with state migration.`,
	// Long: çƒ­é‡è½½ XDP ç¨‹åºï¼šåº”ç”¨æ–°é…ç½®è€Œä¸ä¸­æ–­è¿æ¥ã€‚æ”¯æŒå®¹é‡å˜æ›´æ—¶çš„çŠ¶æ€è¿ç§»ã€‚
	Run: func(cmd *cobra.Command, args []string) {
		common.EnsureStandaloneMode()

		if err := app.ReloadXDP(cmd.Context(), interfaces); err != nil {
			cmd.PrintErrln(err)
			os.Exit(1)
		}
		fmt.Println("âœ… XDP program reloaded successfully")
	},
}

func init() {
	SystemCmd.AddCommand(systemInitCmd)
	SystemCmd.AddCommand(systemStatusCmd)
	SystemCmd.AddCommand(systemTestCmd)
	SystemCmd.AddCommand(systemDaemonCmd)

	systemLoadCmd.Flags().StringSliceVarP(&interfaces, "interface", "i", nil, "Interfaces to attach XDP to")
	SystemCmd.AddCommand(systemLoadCmd)

	systemReloadCmd.Flags().StringSliceVarP(&interfaces, "interface", "i", nil, "Interfaces to attach XDP to")
	SystemCmd.AddCommand(systemReloadCmd)
}

func showStatus(ctx context.Context, s *sdk.SDK) error {
	fmt.Println("âœ… XDP Program Status: Loaded and Running")

	// Get stats
	pass, drops, err := s.Stats.GetCounters()
	if err != nil {
		fmt.Printf("âš ï¸  Could not retrieve statistics: %v\n", err)
	} else {
		fmt.Printf("ğŸ“Š Global Drop Count: %d packets\n", drops)
		fmt.Printf("ğŸ“Š Global Pass Count: %d packets\n", pass)

		// Show detailed drop stats
		details, err := s.Stats.GetDropDetails()
		if err == nil && len(details) > 0 {
			// Sort by count descending
			sort.Slice(details, func(i, j int) bool {
				return details[i].Count > details[j].Count
			})

			fmt.Println("\n   ğŸš« Top Drops by Reason & Source:")
			fmt.Printf("   %-20s %-8s %-40s %-8s %s\n", "Reason", "Proto", "Source IP", "DstPort", "Count")
			fmt.Printf("   %s\n", strings.Repeat("-", 90))

			for _, d := range details {
				fmt.Printf("   %-20d %-8d %-40s %-8d %d\n", d.Reason, d.Protocol, d.SrcIP, d.DstPort, d.Count)
			}
		} else if err != nil {
			fmt.Printf("âš ï¸  Could not retrieve detailed drop statistics: %v\n", err)
		}
	}
	return nil
}
